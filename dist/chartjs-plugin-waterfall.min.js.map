{"version":3,"file":"chartjs-plugin-waterfall.min.js","sources":["../src/drawStepLines.js","../src/index.js"],"sourcesContent":["import groupBy from 'lodash/groupBy';\n\nconst DEBUG = false;\n\nconst drawOnCanvas = (context, options, currentDatapointValues, nextDatapointValues) => {\n  let currentStackBase = currentDatapointValues.stackBase;\n  let nextStackBase = nextDatapointValues.stackBase;\n  let currentStackTopYPos = currentDatapointValues.stackTopYPos;\n  let nextStackTopYPos = nextDatapointValues.stackTopYPos;\n\n  /* If the heights match top to bottom or bottom to top then\n  flip the top coordinates to be at the bottom so that a horizontal step line is drawn */\n  if (currentStackTopYPos === nextStackBase) {\n    nextStackTopYPos = nextStackBase;\n    nextStackBase = nextDatapointValues.dummyStackBase;\n  } else if (currentStackBase === nextStackTopYPos) {\n    currentStackTopYPos = currentStackBase;\n    currentStackBase = currentDatapointValues.dummyStackBase;\n  }\n\n  // We need to flip the y co-ords if one of the datasets is negative and the other isn't\n  if (!currentDatapointValues.isPositive && nextDatapointValues.isPositive) {\n    nextStackTopYPos = nextStackBase;\n    nextStackBase = nextDatapointValues.stackTopYPos;\n  }\n\n  if (currentDatapointValues.isPositive && !nextDatapointValues.isPositive) {\n    currentStackTopYPos = currentStackBase;\n    currentStackBase = currentDatapointValues.stackTopYPos;\n  }\n\n  // Draws co-ords on the canvas to allow easier debugging\n  if (DEBUG) {\n    context.font = '9px Arial';\n    context.fillStyle = '#000';\n    context.fillText(`TR: ${currentDatapointValues.stackRightXPos.toFixed(0)}`, currentDatapointValues.stackRightXPos, currentStackTopYPos);\n    context.fillText(`TL: ${nextDatapointValues.stackLeftXPos.toFixed(0)}`, nextDatapointValues.stackLeftXPos, nextStackTopYPos);\n    context.fillText(`BL: ${nextStackBase.toFixed(0)}`, nextDatapointValues.stackLeftXPos, nextStackBase);\n    context.fillText(`BR: ${currentStackBase.toFixed(0)}`, currentDatapointValues.stackRightXPos, currentStackBase);\n  }\n\n  // Makes sure that each step line is consistent\n  const yStart = currentStackTopYPos > nextStackTopYPos ? currentStackTopYPos : nextStackTopYPos;\n  const yEnd = currentStackBase > nextStackBase ? currentStackBase : nextStackBase;\n\n  // Gradient from top of second box to bottom of both boxes\n  const gradient = context.createLinearGradient(0, yStart, 0, yEnd);\n\n  // Dataset options take priority if they are specified\n  const startColor = currentDatapointValues.options.startColor || options.startColor;\n  const endColor = currentDatapointValues.options.endColor || options.endColor;\n  const startColorStop = currentDatapointValues.options.startColorStop || options.startColorStop;\n  const endColorStop = currentDatapointValues.options.endColorStop || options.endColorStop;\n\n  gradient.addColorStop(startColorStop, startColor);\n  gradient.addColorStop(endColorStop, endColor);\n\n  context.fillStyle = gradient;\n\n  context.beginPath();\n\n  // top right of first box\n  context.lineTo(currentDatapointValues.stackRightXPos, currentStackTopYPos);\n  // top left of second box\n  context.lineTo(nextDatapointValues.stackLeftXPos, nextStackTopYPos);\n  // bottom left of second box\n  context.lineTo(nextDatapointValues.stackLeftXPos, nextStackBase);\n  // bottom right of first box\n  context.lineTo(currentDatapointValues.stackRightXPos, currentStackBase);\n\n  context.fill();\n};\n\nexport default (chart) => {\n  const context = chart.ctx;\n  const datasets = chart.data.datasets;\n  const options = chart.options.plugins.waterFallPlugin.stepLines;\n  const stackedDatasets = groupBy(datasets, 'stack');\n  const newDatasets = [];\n\n  const getModel = (dataset) => {\n    const firstKey = Object.keys(dataset._meta)[0];\n\n    return dataset._meta[firstKey].data[0]._model;\n  };\n\n  Object.keys(stackedDatasets).forEach((key) => {\n    const currentStackedDataset = stackedDatasets[key].filter(x => x.data[0] !== 0);\n\n    if (!currentStackedDataset.every(x => x.waterfall.dummyStack)) {\n      const nonDummyStacks = currentStackedDataset.filter(dataset => !dataset.waterfall.dummyStack);\n      const bases = nonDummyStacks.map(dataset => getModel(dataset).base);\n      const lowestBase = Math.max(...bases);\n\n      const dummStackBases = currentStackedDataset.map(dataset => getModel(dataset).base);\n      const lowestDummyStackBase = Math.max(...dummStackBases);\n\n      // Loop through each sub stack\n      const properties = currentStackedDataset.map((dataset) => {\n        const model = getModel(dataset);\n\n        return {\n          stackRightXPos: model.x + (model.width / 2),\n          stackLeftXPos: model.x - (model.width / 2),\n          stackTopYPos: model.y,\n          stackBase: lowestBase,\n          dummyStackBase: lowestDummyStackBase,\n          isPositive: dataset.data[0] > 0,\n          options: dataset.waterfall.stepLines,\n        };\n      });\n\n      newDatasets.push(properties);\n    }\n  });\n\n  // Gets the values for the steplines at the top of the stack\n  const getDatapointsValues = (dataset) => {\n    const index = dataset.length - 1;\n\n    return {\n      stackRightXPos: dataset[index].stackRightXPos,\n      stackLeftXPos: dataset[index].stackLeftXPos,\n      stackTopYPos: dataset[index].stackTopYPos,\n      stackBase: dataset[index].stackBase,\n      dummyStackBase: dataset[index].dummyStackBase,\n      isPositive: dataset[index].isPositive,\n      options: dataset[index].options,\n    };\n  };\n\n  for (let i = 0; i < newDatasets.length; i += 1) {\n    const currentDataSet = newDatasets[i];\n\n    if (i !== newDatasets.length - 1) {\n      const nextDataSet = newDatasets[i + 1];\n      const currentDatapointValues = getDatapointsValues(currentDataSet);\n      const nextDatapointValues = getDatapointsValues(nextDataSet);\n\n      if (currentDatapointValues.stackTopYPos === nextDatapointValues.stackTopYPos ||\n        currentDatapointValues.stackBase === nextDatapointValues.stackTopYPos ||\n        currentDatapointValues.stackTopYPos === nextDatapointValues.stackBase) {\n        drawOnCanvas(context, options, currentDatapointValues, nextDatapointValues);\n      }\n    }\n  }\n};\n","import merge from 'lodash/merge';\n\nimport drawStepLines from './drawStepLines';\n\nconst defaultOptions = {\n  waterFallPlugin: {\n    stepLines: {\n      enabled: true,\n      startColorStop: 0,\n      endColorStop: 0.6,\n      startColor: 'rgba(0, 0, 0, 0.55)', // opaque\n      endColor: 'rgba(0, 0, 0, 0)', // transparent\n    },\n  },\n};\n\nconst status = {};\n\nconst filterDummyStacks = (legendItem, chartData) => {\n  const currentDataset = chartData.datasets[legendItem.datasetIndex];\n\n  return !currentDataset.waterfall.dummyStack;\n};\n\nconst initializeDatasets = (chart) => {\n  chart.data.datasets.forEach((dataset) => {\n    dataset.waterfall = merge({}, {\n      stepLines: {},\n    }, dataset.waterfall);\n\n    if (dataset.waterfall.dummyStack) {\n      dataset.backgroundColor = 'rgba(0, 0, 0, 0)';\n    }\n  });\n};\n\nconst waterFallPlugin = {\n  beforeInit: (chart) => {\n    status[chart.id] = {\n      readyToDrawStepLines: false,\n    };\n  },\n  afterInit: (chart) => {\n    initializeDatasets(chart);\n\n    chart.options.plugins = merge({}, defaultOptions, chart.options.plugins);\n    chart.options.tooltips.filter = filterDummyStacks;\n    chart.options.legend.labels.filter = filterDummyStacks;\n\n    // Can't override onComplete function because it gets overwridden if user using React\n    setTimeout(() => {\n      status[chart.id].readyToDrawStepLines = true;\n      if (chart.ctx !== null) {\n        chart.draw();\n      }\n    }, chart.options.animation.duration);\n  },\n  afterDraw: (chart) => {\n    const options = chart.options.plugins.waterFallPlugin;\n\n    initializeDatasets(chart);\n\n    if (options.stepLines.enabled &&\n        status[chart.id].readyToDrawStepLines) {\n      drawStepLines(chart);\n    }\n  },\n};\n\nexport default waterFallPlugin;\n"],"names":["drawOnCanvas","context","options","currentDatapointValues","nextDatapointValues","currentStackBase","stackBase","nextStackBase","currentStackTopYPos","stackTopYPos","nextStackTopYPos","dummyStackBase","isPositive","yStart","yEnd","gradient","createLinearGradient","startColor","endColor","startColorStop","endColorStop","addColorStop","fillStyle","beginPath","lineTo","stackRightXPos","stackLeftXPos","fill","defaultOptions","status","filterDummyStacks","legendItem","chartData","datasets","datasetIndex","waterfall","dummyStack","initializeDatasets","chart","data","forEach","dataset","merge","backgroundColor","id","plugins","tooltips","filter","legend","labels","readyToDrawStepLines","ctx","draw","animation","duration","waterFallPlugin","stepLines","enabled","stackedDatasets","groupBy","newDatasets","getModel","firstKey","Object","keys","_meta","_model","key","currentStackedDataset","x","every","bases","map","base","lowestBase","Math","max","dummStackBases","lowestDummyStackBase","properties","model","width","y","push","getDatapointsValues","index","length","i","currentDataSet","nextDataSet"],"mappings":"25CAIMA,EAAe,SAACC,EAASC,EAASC,EAAwBC,OAC1DC,EAAmBF,EAAuBG,UAC1CC,EAAgBH,EAAoBE,UACpCE,EAAsBL,EAAuBM,aAC7CC,EAAmBN,EAAoBK,aAIvCD,IAAwBD,KACPA,IACHH,EAAoBO,gBAC3BN,IAAqBK,MACRL,IACHF,EAAuBQ,iBAIvCR,EAAuBS,YAAcR,EAAoBQ,eACzCL,IACHH,EAAoBK,cAGlCN,EAAuBS,aAAeR,EAAoBQ,eACtCP,IACHF,EAAuBM,kBActCI,EAA+BH,EAAtBF,EAAyCA,EAAsBE,EACxEI,EAA0BP,EAAnBF,EAAmCA,EAAmBE,EAG7DQ,EAAWd,EAAQe,qBAAqB,EAAGH,EAAQ,EAAGC,GAGtDG,EAAad,EAAuBD,QAAQe,YAAcf,EAAQe,WAClEC,EAAWf,EAAuBD,QAAQgB,UAAYhB,EAAQgB,SAC9DC,EAAiBhB,EAAuBD,QAAQiB,gBAAkBjB,EAAQiB,eAC1EC,EAAejB,EAAuBD,QAAQkB,cAAgBlB,EAAQkB,eAEnEC,aAAaF,EAAgBF,KAC7BI,aAAaD,EAAcF,KAE5BI,UAAYP,IAEZQ,cAGAC,OAAOrB,EAAuBsB,eAAgBjB,KAE9CgB,OAAOpB,EAAoBsB,cAAehB,KAE1Cc,OAAOpB,EAAoBsB,cAAenB,KAE1CiB,OAAOrB,EAAuBsB,eAAgBpB,KAE9CsB,QClEJC,EAAiB,iBACJ,WACJ,UACA,iBACO,eACF,cACF,+BACF,sBAKVC,EAAS,GAETC,EAAoB,SAACC,EAAYC,UACdA,EAAUC,SAASF,EAAWG,cAE9BC,UAAUC,YAG7BC,EAAqB,SAACC,KACpBC,KAAKN,SAASO,QAAQ,SAACC,KACnBN,UAAYO,EAAM,GAAI,WACjB,IACVD,EAAQN,WAEPM,EAAQN,UAAUC,eACZO,gBAAkB,6BAKR,YACV,SAACL,KACJA,EAAMM,IAAM,uBACK,cAGf,SAACN,KACSA,KAEbpC,QAAQ2C,QAAUH,EAAM,GAAId,EAAgBU,EAAMpC,QAAQ2C,WAC1D3C,QAAQ4C,SAASC,OAASjB,IAC1B5B,QAAQ8C,OAAOC,OAAOF,OAASjB,aAG1B,aACFQ,EAAMM,IAAIM,sBAAuB,EACtB,OAAdZ,EAAMa,OACFC,QAEPd,EAAMpC,QAAQmD,UAAUC,qBAElB,SAAChB,OACJpC,EAAUoC,EAAMpC,QAAQ2C,QAAQU,kBAEnBjB,GAEfpC,EAAQsD,UAAUC,SAClB5B,EAAOS,EAAMM,IAAIM,+BDUTZ,OACRrC,EAAUqC,EAAMa,IAChBlB,EAAWK,EAAMC,KAAKN,SACtB/B,EAAUoC,EAAMpC,QAAQ2C,QAAQU,gBAAgBC,UAChDE,EAAkBC,EAAQ1B,EAAU,SACpC2B,EAAc,GAEdC,EAAW,SAACpB,OACVqB,EAAWC,OAAOC,KAAKvB,EAAQwB,OAAO,UAErCxB,EAAQwB,MAAMH,GAAUvB,KAAK,GAAG2B,eAGlCF,KAAKN,GAAiBlB,QAAQ,SAAC2B,OAC9BC,EAAwBV,EAAgBS,GAAKpB,OAAO,mBAAmB,IAAdsB,EAAE9B,KAAK,SAEjE6B,EAAsBE,MAAM,mBAAKD,EAAElC,UAAUC,aAAa,KAEvDmC,EADiBH,EAAsBrB,OAAO,mBAAYN,EAAQN,UAAUC,aACrDoC,IAAI,mBAAWX,EAASpB,GAASgC,OACxDC,EAAaC,KAAKC,iBAAOL,IAEzBM,EAAiBT,EAAsBI,IAAI,mBAAWX,EAASpB,GAASgC,OACxEK,EAAuBH,KAAKC,iBAAOC,IAGnCE,EAAaX,EAAsBI,IAAI,SAAC/B,OACtCuC,EAAQnB,EAASpB,SAEhB,gBACWuC,EAAMX,EAAKW,EAAMC,MAAQ,gBAC1BD,EAAMX,EAAKW,EAAMC,MAAQ,eAC1BD,EAAME,YACTR,iBACKI,aACc,EAAlBrC,EAAQF,KAAK,WAChBE,EAAQN,UAAUqB,eAInB2B,KAAKJ,cAKfK,EAAsB,SAAC3C,OACrB4C,EAAQ5C,EAAQ6C,OAAS,QAExB,gBACW7C,EAAQ4C,GAAO5D,6BAChBgB,EAAQ4C,GAAO3D,2BAChBe,EAAQ4C,GAAO5E,uBAClBgC,EAAQ4C,GAAO/E,yBACVmC,EAAQ4C,GAAO1E,0BACnB8B,EAAQ4C,GAAOzE,mBAClB6B,EAAQ4C,GAAOnF,UAInBqF,EAAI,EAAGA,EAAI3B,EAAY0B,OAAQC,GAAK,EAAG,KACxCC,EAAiB5B,EAAY2B,MAE/BA,IAAM3B,EAAY0B,OAAS,EAAG,KAC1BG,EAAc7B,EAAY2B,EAAI,GAC9BpF,EAAyBiF,EAAoBI,GAC7CpF,EAAsBgF,EAAoBK,GAE5CtF,EAAuBM,eAAiBL,EAAoBK,cAC9DN,EAAuBG,YAAcF,EAAoBK,cACzDN,EAAuBM,eAAiBL,EAAoBE,aAC/CL,EAASC,EAASC,EAAwBC,MC9E3CkC"}